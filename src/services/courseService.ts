

import { db } from "@/lib/firebase-client";
import { collection, addDoc, getDocs, doc, getDoc, updateDoc, setDoc, deleteDoc, writeBatch, query, where, getCountFromServer, serverTimestamp } from "firebase/firestore";
import type { Course } from "@/lib/types";

// Type for a new course, omitting the 'id' as it will be generated by Firestore
export type NewCourse = Omit<Course, 'id' | 'createdAt'>;
export type UpdatableCourse = Omit<Course, 'id' | 'createdAt'>;


// Function to add a new course to Firestore
export const addCourse = async (courseData: NewCourse): Promise<string> => {
  const batch = writeBatch(db);
  const newDocRef = doc(collection(db, "courses"));
  
  batch.set(newDocRef, {
    ...courseData,
    id: newDocRef.id,
    createdAt: serverTimestamp(),
  });

  try {
    await batch.commit();
    return newDocRef.id;
  } catch (error) {
    console.error("Error adding course: ", error);
    throw new Error("Failed to add course.");
  }
};

// Function to get all courses from Firestore
export const getCourses = async (): Promise<Course[]> => {
  try {
    const querySnapshot = await getDocs(collection(db, "courses"));
    const courses: Course[] = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      if (data.createdAt && typeof data.createdAt.toDate === 'function') {
        data.createdAt = data.createdAt.toDate().toISOString();
      }
      courses.push({ id: doc.id, ...data } as Course);
    });
    return courses;
  } catch (error) {
    console.error("Error getting courses: ", error);
    throw new Error("Failed to get courses.");
  }
};

/**
 * Gets all courses for a specific grade.
 * @param grade - The grade to filter courses by.
 * @returns An array of courses for the specified grade.
 */
export const getCoursesByGrade = async (grade: string): Promise<Course[]> => {
    try {
        const q = query(collection(db, "courses"), where("grade", "==", grade), where("type", "==", "academic"));
        const querySnapshot = await getDocs(q);
        const courses: Course[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.createdAt && typeof data.createdAt.toDate === 'function') {
              data.createdAt = data.createdAt.toDate().toISOString();
            }
            courses.push(data as Course);
        });
        return courses;
    } catch (error) {
        console.error("Error getting courses by grade:", error);
        throw new Error("Failed to get courses for the specified grade.");
    }
};

/**
 * Gets all courses of a specific type (academic or support).
 * @param type - The type of course to filter by.
 * @returns An array of courses.
 */
export const getCoursesByType = async (type: "academic" | "support"): Promise<Course[]> => {
    try {
        const q = query(collection(db, "courses"), where("type", "==", type));
        const querySnapshot = await getDocs(q);
        const courses: Course[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.createdAt && typeof data.createdAt.toDate === 'function') {
              data.createdAt = data.createdAt.toDate().toISOString();
            }
            courses.push(data as Course);
        });
        return courses;
    } catch (error) {
        console.error(`Error getting ${type} courses:`, error);
        throw new Error(`Failed to get ${type} courses.`);
    }
};

/**
 * Gets all available support courses.
 * @returns An array of support courses.
 */
export const getSupportCourses = async (): Promise<Course[]> => {
  return getCoursesByType("support");
};


// Function to get a single course by ID from Firestore
export const getCourse = async (id: string): Promise<Course | null> => {
    try {
        const docRef = doc(db, "courses", id);
        const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
            const data = docSnap.data();
            if (data.createdAt && typeof data.createdAt.toDate === 'function') {
              data.createdAt = data.createdAt.toDate().toISOString();
            }
            return { id: docSnap.id, ...data } as Course;
        } else {
            console.log("No such course document!");
            return null;
        }
    } catch (error) {
        console.error("Error getting course:", error);
        throw new Error("Failed to get course.");
    }
}

// Function to update a course in Firestore
export const updateCourse = async (id: string, courseData: Partial<UpdatableCourse>): Promise<void> => {
    try {
        const courseRef = doc(db, "courses", id);
        await updateDoc(courseRef, courseData);
    } catch (error) {
        console.error("Error updating course: ", error);
        throw new Error("Failed to update course.");
    }
}

// Function to delete a course from Firestore
export const deleteCourse = async (id: string): Promise<void> => {
    try {
        const courseRef = doc(db, "courses", id);
        await deleteDoc(courseRef);
        // Note: In a real-world application, you would also want to handle
        // deleting associated data like enrollments, grades, etc.
        // For simplicity, we are only deleting the course document here.
    } catch (error) {
        console.error("Error deleting course: ", error);
        throw new Error("Failed to delete course.");
    }
}

// Optimized function to get the count of all courses
export const getCourseCount = async (): Promise<number> => {
  try {
    const snapshot = await getCountFromServer(collection(db, "courses"));
    return snapshot.data().count;
  } catch (error) {
    console.error("Error getting course count:", error);
    throw new Error("Failed to get course count.");
  }
};
