

import { db } from "@/lib/firebase-client";
import { collection, addDoc, getDocs, doc, getDoc, updateDoc, setDoc, deleteDoc, writeBatch, query, where, getCountFromServer, serverTimestamp } from "firebase/firestore";
import type { Course } from "@/lib/types";

// Type for a new course, omitting the 'id' as it will be generated by Firestore
export type NewCourse = Omit<Course, 'id' | 'createdAt'>;
export type UpdatableCourse = Omit<Course, 'id' | 'createdAt'>;


// Function to add a new course to Firestore
export const addCourse = async (courseData: NewCourse): Promise<string> => {
  if (!db) throw new Error('Firestore is not initialized. Cannot add course.');
  const batch = writeBatch(db);
  const newDocRef = doc(collection(db, "courses"));
  
  batch.set(newDocRef, {
    ...courseData,
    id: newDocRef.id,
    createdAt: serverTimestamp(),
  });

  try {
    await batch.commit();
    return newDocRef.id;
  } catch (error) {
    console.error("Error adding course: ", error);
    throw new Error("Failed to add course.");
  }
};

// Function to get all courses from Firestore
export const getCourses = async (): Promise<Course[]> => {
  try {
    if (!db) {
      console.warn('Firestore not initialized. getCourses() returning empty list.');
      return [];
    }
    const querySnapshot = await getDocs(collection(db, "courses"));
    const courses: Course[] = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      if (data.createdAt && typeof data.createdAt.toDate === 'function') {
        data.createdAt = data.createdAt.toDate().toISOString();
      }
      courses.push({ id: doc.id, ...data } as Course);
    });
    return courses;
  } catch (error) {
    console.error("Error getting courses: ", error);
    throw new Error("Failed to get courses.");
  }
};

/**
 * Gets all courses for a specific grade.
 * @param grade - The grade to filter courses by.
 * @returns An array of courses for the specified grade.
 */
export const getCoursesByGrade = async (grade: string): Promise<Course[]> => {
    try {
    if (!db) {
      console.warn('Firestore not initialized. getCoursesByGrade() returning empty list.');
      return [];
    }
    const q = query(collection(db, "courses"), where("grade", "==", grade), where("type", "==", "academic"));
    const querySnapshot = await getDocs(q);
        const courses: Course[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.createdAt && typeof data.createdAt.toDate === 'function') {
              data.createdAt = data.createdAt.toDate().toISOString();
            }
            courses.push(data as Course);
        });
        return courses;
    } catch (error) {
        console.error("Error getting courses by grade:", error);
        throw new Error("Failed to get courses for the specified grade.");
    }
};

/**
 * Gets all courses of a specific type (academic or support).
 * @param type - The type of course to filter by.
 * @returns An array of courses.
 */
export const getCoursesByType = async (type: "academic" | "support"): Promise<Course[]> => {
    try {
    if (!db) {
      console.warn('Firestore not initialized. getCoursesByType() returning empty list.');
      return [];
    }
    const q = query(collection(db, "courses"), where("type", "==", type));
    const querySnapshot = await getDocs(q);
        const courses: Course[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.createdAt && typeof data.createdAt.toDate === 'function') {
              data.createdAt = data.createdAt.toDate().toISOString();
            }
            courses.push(data as Course);
        });
        return courses;
    } catch (error) {
        console.error(`Error getting courses:`, error);
        throw new Error(`Failed to get courses.`);
    }
};

/**
 * Gets all available support courses.
 * @returns An array of support courses.
 */
export const getSupportCourses = async (): Promise<Course[]> => {
  return getCoursesByType("support");
};


// Function to get a single course by ID from Firestore
export const getCourse = async (id: string): Promise<Course | null> => {
    try {
    if (!db) {
      console.warn('Firestore not initialized. getCourse() returning null.');
      return null;
    }
    const docRef = doc(db, "courses", id);
    const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
            const data = docSnap.data();
            if (data.createdAt && typeof data.createdAt.toDate === 'function') {
              data.createdAt = data.createdAt.toDate().toISOString();
            }
            return { id: docSnap.id, ...data } as Course;
        } else {
            console.warn("‚ö†Ô∏è Course not found in Firestore. ID:", id);
            console.warn("üí° This course may have been deleted. Consider cleaning up enrollments.");
            return null;
        }
    } catch (error) {
        console.error("Error getting course:", error);
        throw new Error("Failed to get course.");
    }
}

// Function to update a course in Firestore
export const updateCourse = async (id: string, courseData: Partial<UpdatableCourse>): Promise<void> => {
    try {
    if (!db) throw new Error('Firestore is not initialized. Cannot update course.');
    const courseRef = doc(db, "courses", id);
    await updateDoc(courseRef, courseData);
    } catch (error) {
        console.error("Error updating course: ", error);
        throw new Error("Failed to update course.");
    }
}

// Function to delete a course from Firestore
export const deleteCourse = async (id: string): Promise<void> => {
    try {
    if (!db) throw new Error('Firestore is not initialized. Cannot delete course.');
    const courseRef = doc(db, "courses", id);
    await deleteDoc(courseRef);
        // Note: In a real-world application, you would also want to handle
        // deleting associated data like enrollments, grades, etc.
        // For simplicity, we are only deleting the course document here.
    } catch (error) {
        console.error("Error deleting course: ", error);
        throw new Error("Failed to delete course.");
    }
}

// Optimized function to get the count of all courses
export const getCourseCount = async (): Promise<number> => {
  try {
    if (!db) {
      console.warn('Firestore not initialized. getCourseCount() returning 0.');
      return 0;
    }
    const snapshot = await getCountFromServer(collection(db, "courses"));
    return snapshot.data().count;
  } catch (error) {
    console.error("Error getting course count:", error);
    throw new Error("Failed to get course count.");
  }
};

// Function to assign a teacher to multiple courses
export const assignTeacherToCourses = async (teacherId: string, teacherName: string, courseIds: string[]): Promise<void> => {
  try {
    if (!db) throw new Error('Firestore is not initialized. Cannot assign teacher to courses.');
    const batch = writeBatch(db);
    
    for (const courseId of courseIds) {
      const courseRef = doc(db, "courses", courseId);
      const courseDoc = await getDoc(courseRef);
      
      if (courseDoc.exists()) {
        const courseData = courseDoc.data() as Course;
        const existingTeachers = courseData.teachers || [];
        
        // Check if teacher is already assigned
        if (!existingTeachers.some(t => t.id === teacherId)) {
          const updatedTeachers = [...existingTeachers, { id: teacherId, name: teacherName }];
          batch.update(courseRef, { teachers: updatedTeachers });
        }
      }
    }
    
    await batch.commit();
  } catch (error) {
    console.error("Error assigning teacher to courses:", error);
    throw new Error("Failed to assign teacher to courses.");
  }
};

// Function to remove a teacher from all courses
export const removeTeacherFromAllCourses = async (teacherId: string): Promise<void> => {
  try {
    if (!db) throw new Error('Firestore is not initialized. Cannot remove teacher from courses.');
    const coursesSnapshot = await getDocs(collection(db, "courses"));
    const batch = writeBatch(db);
    
    coursesSnapshot.forEach((doc) => {
      const courseData = doc.data() as Course;
      if (courseData.teachers?.some(t => t.id === teacherId)) {
        const updatedTeachers = courseData.teachers.filter(t => t.id !== teacherId);
        batch.update(doc.ref, { teachers: updatedTeachers });
      }
    });
    
    await batch.commit();
  } catch (error) {
    console.error("Error removing teacher from courses:", error);
    throw new Error("Failed to remove teacher from courses.");
  }
};
