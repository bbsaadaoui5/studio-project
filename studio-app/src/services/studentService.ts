

import { db } from "@/lib/firebase-client";
import { collection, getDocs, doc, getDoc, addDoc, updateDoc, DocumentData, query, where, setDoc, writeBatch, orderBy, limit, runTransaction, getCountFromServer, serverTimestamp } from "firebase/firestore";
import type { Student } from "@/lib/types";
import { isDevMockEnabled, getMockStudents, getMockStudent } from "@/lib/dev-mock";

// Type for a new student, omitting the 'id' as it will be generated by Firestore
export type NewStudent = Omit<Student, 'id'>;
export type UpdatableStudent = Omit<Student, 'id' | 'enrollmentDate'>;

const getNextStudentId = async (): Promise<string> => {
  if (!db) throw new Error('Firestore is not initialized. Cannot get next student ID.');
  const counterRef = doc(db, "counters", "studentId");

  return runTransaction(db, async (transaction) => {
    const counterDoc = await transaction.get(counterRef);
        let nextId = 1;
        if (counterDoc.exists()) {
            nextId = counterDoc.data().currentId + 1;
        }
        transaction.set(counterRef, { currentId: nextId }, { merge: true });
        return `STU${String(nextId).padStart(3, '0')}`;
    });
};


// Function to add a new student to Firestore
export const addStudent = async (studentData: Omit<NewStudent, 'id' | 'status' | 'enrollmentDate' | 'idNumber'>): Promise<string> => {
  if (!db) throw new Error('Firestore is not initialized. Cannot add student.');
  const batch = writeBatch(db);
  const studentId = await getNextStudentId();
  const newDocRef = doc(db, "students", studentId);
  
  const newStudentData = {
    ...studentData,
    // Ensure arrays exist to avoid undefined in Firestore
    supportCourseIds: studentData.supportCourseIds || [],
    teachers: studentData.teachers || [],
    idNumber: studentId,
    id: studentId,
    status: "active" as const,
    enrollmentDate: serverTimestamp(),
  }
  batch.set(newDocRef, newStudentData);

  try {
    await batch.commit();
    return studentId;
  } catch (error) {
    console.error("Error adding student: ", error);
    throw new Error("Failed to add student.");
  }
};

// Function to get all students from Firestore
export const getStudents = async (): Promise<Student[]> => {
  try {
    if (!db) {
      console.warn('Firestore not initialized. getStudents() returning empty list.');
  if (isDevMockEnabled()) return getMockStudents();
      return [];
    }
    const querySnapshot = await getDocs(collection(db, "students"));
    const students: Student[] = [];
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      // Convert Firestore Timestamp to ISO string
      if (data.enrollmentDate && typeof data.enrollmentDate.toDate === 'function') {
        data.enrollmentDate = data.enrollmentDate.toDate().toISOString();
      }
      students.push(data as Student);
    });
    return students;
  } catch (error) {
    console.error("Error getting students: ", error);
    throw new Error("Failed to get students.");
  }
};

// Function to get all active students from Firestore
export const getActiveStudents = async (): Promise<Student[]> => {
  try {
    if (!db) {
      console.warn('Firestore not initialized. getActiveStudents() returning empty list.');
  if (isDevMockEnabled()) return getMockStudents();
      return [];
    }
    const q = query(collection(db, "students"), where("status", "==", "active"));
    const querySnapshot = await getDocs(q);
    const students: Student[] = [];
    querySnapshot.forEach((doc) => {
       const data = doc.data();
      // Convert Firestore Timestamp to ISO string
      if (data.enrollmentDate && typeof data.enrollmentDate.toDate === 'function') {
        data.enrollmentDate = data.enrollmentDate.toDate().toISOString();
      }
      students.push(data as Student);
    });
    return students;
  } catch (error) {
    console.error("Error getting active students: ", error);
    throw new Error("Failed to get active students.");
  }
}

// Function to get students by grade and class name
export const getStudentsByClass = async (grade: string, className: string): Promise<Student[]> => {
    try {
    if (!db) {
      console.warn('Firestore not initialized. getStudentsByClass() returning empty list.');
  if (isDevMockEnabled()) return getMockStudents();
      return [];
    }
    const q = query(collection(db, "students"), where("grade", "==", grade), where("className", "==", className));
    const querySnapshot = await getDocs(q);
        const students: Student[] = [];
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            // Convert Firestore Timestamp to ISO string
            if (data.enrollmentDate && typeof data.enrollmentDate.toDate === 'function') {
                data.enrollmentDate = data.enrollmentDate.toDate().toISOString();
            }
            students.push(data as Student);
        });
        return students;
    } catch (error) {
        console.error("Error getting students by class:", error);
        throw new Error("Failed to get students by class.");
    }
}


// Function to get a single student by ID from Firestore
export const getStudent = async (id: string): Promise<Student | null> => {
    try {
    if (!db) {
      console.warn('Firestore not initialized. getStudent() returning null.');
  if (isDevMockEnabled()) return getMockStudent(id);
      return null;
    }
    const docRef = doc(db, "students", id);
    const docSnap = await getDoc(docRef);

        if (docSnap.exists()) {
            const data = docSnap.data();
            if (data.enrollmentDate && typeof data.enrollmentDate.toDate === 'function') {
                data.enrollmentDate = data.enrollmentDate.toDate().toISOString();
            }
            return { id: docSnap.id, ...data } as Student;
        } else {
            console.log("No such student document!");
            return null;
        }
    } catch (error) {
        console.error("Error getting student:", error);
        throw new Error("Failed to get student.");
    }
}

// Function to update a student in Firestore
export const updateStudent = async (id: string, studentData: Partial<UpdatableStudent>): Promise<void> => {
    try {
    if (!db) throw new Error('Firestore not initialized. Cannot update student.');
    const studentRef = doc(db, "students", id);
    await updateDoc(studentRef, studentData);
    } catch (error) {
        console.error("Error updating student: ", error);
        throw new Error("Failed to update student.");
    }
}

// Optimized function to get student statistics
export const getStudentStats = async (): Promise<{
  activeCount: number;
  classDistribution: Record<string, number>;
}> => {
  try {
    if (!db) {
      console.warn('Firestore not initialized. getStudentStats() returning zeros.');
  if (isDevMockEnabled()) {
        const students = await getMockStudents();
        return {
          activeCount: students.length,
          classDistribution: students.reduce((acc: Record<string, number>, s) => {
            const g = `Grade ${s.grade}`;
            acc[g] = (acc[g] || 0) + 1;
            return acc;
          }, {}),
        };
      }
      return { activeCount: 0, classDistribution: {} };
    }
    const q = query(collection(db, "students"), where("status", "==", "active"));
    const querySnapshot = await getDocs(q);
    
    let activeCount = 0;
    const classDistribution: Record<string, number> = {};

    querySnapshot.forEach((doc) => {
      const student = doc.data() as Student;
      activeCount++;
      if (student.grade) {
          const group = `Grade ${student.grade}`;
          classDistribution[group] = (classDistribution[group] || 0) + 1;
      }
    });

    return { activeCount, classDistribution };
  } catch (error) {
    console.error("Error getting student stats:", error);
    throw new Error("Failed to get student statistics.");
  }
};
